---
layout: page
title: Add a second rule with more parameters
description: Add a second rule with more parameters
---

The next step is to add another rule to your workflow. We will now (hypothetically)
align our fastqs to a genome of interest. Rememebr the focus of this tutorial is
not what is being excuted in the shell commands but how snakemake is managing the
workflow.

Here is the new Snakefile:

```python
configfile: '../config/config.yaml'

rule all:
    input:
        expand("../results/02_align_fastqs/{sample}.bam", sample = config['samples'])

rule process_fastqs:
    input:  "../resources/fq/{sample}.fastq"
    output: "../results/01_process_fq/{sample}.fastq"
    shell:
            """

            cat {input} > {output}
            printf "\nfq processed.\n" >> {output}

            """

rule align_fastqs:
    input:  "../results/01_process_fq/{sample}.fastq"
    output: "../results/02_align_fastqs/{sample}.bam"
    shell:
            """

            cat {input} > {output}
            printf "\nThis is now an alignment file.\n" >> {output}

            """
```

When adding a new rule the most important thing to consider is the flow of files between
the `input` and `output` directives of each rule and the `input` directive of the master rule, 
rule `all`. Notice that the `input` to the `align_fastqs` rule is the `output` produced by
the `process_fastqs` rule. As there is no `expand` function around in the input files in 
`align_fastqs` the files will be processed through `align_fastqs` one by one, again there
will be 4 instances of `align_fastqs` run.

The next thing to notice is that we have changed the input of rule `all` to expect the
output files from `align_fastqs` instead of `process_fastqs`. This means that snakemake
will no longer search for the output files of `process_fastqs` at the end of the pipeline.
If we wished we could pass the output of both rules to rule all this so:

```python
rule all:
    input:
        expand("../results/01_process_fq/{sample}.fastq", sample = config['samples']), # Use commas to add files
	expand("../results/02_align_fastqs/{sample}.bam", sample = config['samples'])
```

There may be instances when we wish to track the ouputs of multiple rules, particularly,
if pipelines diverge from a serial processing like the basic one we have here that may have
several termination points. 

However, it is important to recognise that when running `snakemake -np`, snakemake is checking
that all the inputs and outputs of each rules are ordered in a logical manner. If a rule output
does not feed directy into either the input of another rule or rule all it will throw an error. 
Snakemake also checks that any necessary input files, i.e. file not generated by a rule, exist 
in the file system. 

***

**Additional directives**

Whilst the above Snakefile would run as is, I'm going to add some additional directves to it to
demostrate some of the additional functionality that snakemake offers. Note that most of these 
parameters are not required, or even relevant, to run this basic process. This purpose here is 
to demostrate the options snakemake give you not how these affect the sheel script.

Here is the updated `align_fastqs` rule`:

```python
rule align_fastqs:
    input:  "../results/01_process_fq/{sample}.fastq"
    output: temp("../results/02_align_fastqs/{sample}.bam")
    log: "../results/00LOGS/02_align_fastqs/{sample}.log"
    params: config['reference']
    conda: "../envs/ldsr.yml"
    envmodules: "libgit2/1.1.0", "R/4.2.0"
    message: "Running alignment for {wildcards.sample}"
    priority: 50
    shell:
            "scripts/align_fastqs.sh {input} {output} {params} {wildcards.sample} &> {log}"
```


Let's explain each new directive one at a time:

- **log** - The file and dirpath for your stderr and / or stdout output
- **params** -  offers the versitility of passing information to your shell command that is different
to the contents of `{input}`, `{output}` or the `wildcards` you have set. Sometimes software requires
file prefixes rather than filenames as input for example.
- **conda** -  This tells snakemake which virtual environment to use for the execution of this rule.
Note that you can use different envs for different rules.
- **envmodules** - Allows you to load modules that may be available in your cluster environment.
No need to type `module load libgit2/1.1.0` any more.
- **message** - This prints a message to the general log file whenever a single job is run. I find this
useful if I have multiple `wildcards` operating in a single rule.
- **priority** - This takes an integer as input and allows fine control ove which rules have higher queueing
priority. This is very useful when running large jobs with lots of large intermediate temporary files that
can cause you to overshoot your memory capacity on `sratch`.
- **temp()** - Indicates to snakemake which files are temporary. These will be deleted once every rules that
needs to use them has finshed using them. (Note: that these files shouldn't be passed to rule all.)
- **{wildcards.sample}** - Notice that if we want to use `{sample}` wildcard in the `message` directive or within
the shell command we need to precede it with {.wildcards}. TODO: WHY?  
- **align_fastqs.sh** - When you have a large chunk of code to process it's often cleaner to use a script.

    ```bash
    #!/bin/bash
    cat $1 > $2
    printf "\nThis is now an alignment file using reference $3 for sample $4.\n" >> $2
    ```

Note that this is very much the same as the bash code in the original version of the `align_fastqs`
rule with the reference and wildcards positional parameter inputs added. (More ore info on bash positional
paramters can be found [here](https://en.wikibooks.org/wiki/Bash_Shell_Scripting/Positional_Parameters)).

***

Using R and Python


TODO: Add page for details on make, add shell script and rule specific slurm params



***

Move on to [snakemake environment setup]({{ site.baseurl }}/pages/snakemake/02_snakemake_env_setup.html), or back to [Run basic process]({{ site.baseurl }}/index.html).
